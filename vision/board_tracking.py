#!usr/bin/env python

'''
Track the pose of a pre-generated aruco grid board
Note: a priori grid geometry is imported from consts.py
'''

import numpy as np
import cv2
import cv2.aruco as aruco
import glob
import sys

# import files from various directories by modifying the python path
# depending on their location
import extract_calibration

sys.path.append('./create_markers/')
from consts import *

DISPLAY = True # this displays camera output to a screen on the machine

# import the grid board geometry to track
board = aruco.GridBoard_create(ROWS, COLS, realMarkerLength, realMarkerSeparation, aruco_dict)
# note this function is deterministic so it will match the board
# generated by `create_board.py` as long as the parameters from
# `consts.py` don't change.

# init video capture
cap = cv2.VideoCapture(0)

# get existing calibration data for pose estimation
mtx = extract_calibration.camera_matrix
dist = extract_calibration.dist_matrix

while True:
    ret, frame = cap.read()

    # convert the frame to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    aruco_dict = aruco.Dictionary_get(aruco.DICT_4X4_50)
    parameters = aruco.DetectorParameters_create()

    # we need to detect the markers before trying to detect the board
    corners, ids, rejected = aruco.detectMarkers(gray, aruco_dict, parameters=parameters)

    # refind not detected markers based on the already detected and the board layout
    aruco.refineDetectedMarkers(gray, board, corners, ids, rejected)
    
    font = cv2.FONT_HERSHEY_SIMPLEX

    if np.all(ids != None): # if there is at least one detected marker
        # estimate pose
        retval, rvec, tvec = aruco.estimatePoseBoard(corners, ids, board, mtx, dist)
        
        # draw on the frame for each marker and the board's origin
        axisLength = 0.1 # the length in meters of the axis drawn on the board
        aruco.drawAxis(frame, mtx, dist, rvec, tvec, axisLength)
        aruco.drawDetectedMarkers(frame, corners, ids)

    if DISPLAY:
        cv2.imshow('frame', frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# release the capture
cap.release()
cv2.destroyAllWindows()

